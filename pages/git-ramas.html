<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ramas y Branching en Git</title>
</head>

<body>
    <header>
        <h1>Ramas y Branching en Git</h1>
        <nav>
            <p>
                <a href="../index.html">Inicio</a> |
                <a href="git-introduccion.html">Introducción</a> |
                <a href="git-que-es.html">¿Qué es Git?</a> |
                <a href="git-instalacion.html">Instalación</a> |
                <a href="git-comandos.html">Comandos</a> |
                <a href="git-ramas.html">Ramas</a> |
                <a href="git-flujo.html">Flujo Completo</a> |
                <a href="git-practica.html">Práctica</a> |
                <a href="git-recursos.html">Recursos</a>
            </p>
        </nav>
    </header>

    <main>
        <section>
            <h2>¿Qué son las Ramas? La Característica Revolucionaria de Git</h2>
            <p>Las <strong>ramas (branches)</strong> son una de las características que hacen a Git extraordinario. Una
                rama es como una <strong>línea de tiempo alternativa</strong> en tu proyecto. Te permite trabajar en
                nuevas
                características, experimentar o corregir bugs sin tocar el código principal estable.</p>

            <p><strong>Analogía:</strong> Imagina que estás escribiendo una novela (el código principal en la rama
                <code>main</code>). De repente tienes una idea para un capítulo nuevo pero no estás seguro si
                funcionará.
                En lugar de reescribir la novela original arriesgándote a arruinarla, creas una <strong>copia
                    alterna</strong>
                (una rama nueva) donde pruebas ese capítulo. Si funciona, lo integras a la novela original; si no,
                simplemente
                descartas esa versión alterna.
            </p>

            <p><strong>¿Por qué son importantes?</strong></p>
            <ul>
                <li><strong>Aislamiento:</strong> Trabajas en una nueva funcionalidad sin romper el código que ya
                    funciona</li>
                <li><strong>Colaboración:</strong> Varios desarrolladores pueden trabajar simultáneamente en diferentes
                    funcionalidades, cada uno en su rama</li>
                <li><strong>Experimentación segura:</strong> Puedes probar ideas locas sin miedo, y si no funcionan,
                    borras
                    la rama sin dejar rastro</li>
                <li><strong>Organización:</strong> Cada tarea/bug/funcionalidad tiene su propia rama, manteniendo el
                    historial limpio y lógico</li>
            </ul>
        </section>

        <section>
            <h2>Cómo Funcionan las Ramas Internamente</h2>
            <p>En Git, una rama es simplemente un <strong>puntero móvil</strong> a un commit. No es una copia física del
                código (¡eso sería lento y consumiría espacio!). Es solo un marcador que dice "esta es la última foto en
                esta línea de tiempo".</p>

            <figure>
                <figcaption>Representación Visual de Ramas</figcaption>
                <pre>
main:     A ← B ← C ← D         ← Rama principal (estable)
                   ↓
              nueva-funcionalidad:  E ← F    ← Rama de desarrollo

HEAD → nueva-funcionalidad  (estás trabajando aquí ahora)
        </pre>
            </figure>

            <p>En este diagrama:</p>
            <ul>
                <li><strong>A, B, C, D, E, F</strong> son commits (fotografías del código en el tiempo)</li>
                <li><strong>main</strong> es la rama principal que apunta al commit D</li>
                <li><strong>nueva-funcionalidad</strong> es una rama que se creó desde C y tiene commits adicionales E y
                    F</li>
                <li><strong>HEAD</strong> es un puntero especial que indica en qué rama estás trabajando actualmente
                </li>
            </ul>

            <p><strong>Lo genial:</strong> Crear una rama es casi instantáneo (Git solo crea un puntero de 40 bytes).
                No hay copiado masivo de archivos.</p>
        </section>

        <section>
            <h2>Comandos Básicos de Ramas</h2>

            <h3>git branch - Ver y crear ramas</h3>
            <pre>git branch                    # Ver todas las ramas locales (* indica la rama actual)
git branch nueva-rama         # Crear una nueva rama (sin moverte a ella)
git branch -d nombre-rama     # Borrar una rama (solo si ya fue fusionada)
git branch -D nombre-rama     # Forzar borrado de rama (aunque no esté fusionada)
git branch -m nuevo-nombre    # Renombrar la rama actual</pre>

            <h3>git checkout - Cambiar de rama</h3>
            <pre>git checkout nombre-rama      # Cambiar a una rama existente
git checkout -b nueva-rama    # Crear y cambiar a una nueva rama (en un solo paso)</pre>

            <p><strong>Comando moderno alternativo:</strong></p>
            <pre>git switch nombre-rama        # Cambiar de rama (más intuitivo)
git switch -c nueva-rama      # Crear y cambiar de rama</pre>

            <p><strong>Nota:</strong> <code>git switch</code> fue introducido en Git 2.23 (2019) para hacer el comando
                más claro. <code>git checkout</code> hace muchas cosas, <code>git switch</code> se especializa solo en
                cambiar ramas.</p>
        </section>

        <section>
            <h2>Fusionar Ramas: Integrando Cambios</h2>

            <h3>git merge - Fusionar ramas</h3>
            <p>Una vez que terminas de trabajar en una rama y todo funciona, quieres <strong>integrar esos cambios a la
                    rama principal</strong>. Esto se llama "merge" (fusión).</p>

            <p><strong>Flujo típico:</strong></p>
            <pre>git checkout main                # Cambias a la rama donde quieres integrar los cambios
git merge nueva-funcionalidad    # Fusionas los cambios de la rama "nueva-funcionalidad"</pre>

            <p><strong>¿Qué pasa internamente?</strong> Git combina los cambios de ambas ramas creando un nuevo commit
                de fusión que tiene dos padres (uno de cada rama).</p>

            <figure>
                <figcaption>Antes del Merge</figcaption>
                <pre>
main:     A ← B ← C ← D
                   ↓
        nueva-func:  E ← F
        </pre>
            </figure>

            <figure>
                <figcaption>Después del Merge</figcaption>
                <pre>
main:     A ← B ← C ← D ← G   (G es el commit de fusión)
                   ↓       ↗
        nueva-func:  E ← F
        </pre>
            </figure>
        </section>

        <section>
            <h2>Tipos de Merge</h2>

            <h3>1. Fast-Forward (Avance Rápido)</h3>
            <p>Ocurre cuando la rama principal no ha tenido cambios nuevos desde que creaste tu rama. Git simplemente
                mueve el puntero hacia adelante sin crear un commit de fusión.</p>
            <pre>git merge nueva-funcionalidad  # Si no hay conflictos ni commits en main, será fast-forward</pre>

            <figure>
                <figcaption>Fast-Forward</figcaption>
                <pre>
Antes:  main → A ← B
                   ↓
              rama → C ← D

Después: main y rama → A ← B ← C ← D
        </pre>
            </figure>

            <h3>2. Three-Way Merge (Fusión de Tres Vías)</h3>
            <p>Ocurre cuando ambas ramas han tenido commits nuevos. Git crea un commit de fusión que combina ambos
                caminos.</p>

            <h3>Forzar un Commit de Fusión</h3>
            <pre>git merge --no-ff nueva-funcionalidad</pre>
            <p>El flag <code>--no-ff</code> (no fast-forward) fuerza a Git a crear un commit de fusión incluso si podría
                hacer fast-forward. Útil para mantener la historia clara de cuándo se integraron funcionalidades.</p>
        </section>

        <section>
            <h2>Conflictos de Fusión: Cuando Git Necesita tu Ayuda</h2>
            <p>A veces, dos ramas modifican las mismas líneas de código de formas diferentes. Git no puede decidir
                automáticamente qué versión mantener, así que te pide ayuda. Esto se llama <strong>conflicto de
                    fusión</strong>.</p>

            <p><strong>¿Cuándo ocurre?</strong></p>
            <ul>
                <li>Dos personas editaron la misma línea de código en ramas diferentes</li>
                <li>Una persona borró un archivo que otra modificó</li>
                <li>Cambios superpuestos que Git no puede resolver automáticamente</li>
            </ul>

            <p><strong>Ejemplo de conflicto:</strong></p>
            <pre>git merge rama-b

Auto-merging archivo.txt
CONFLICT (content): Merge conflict in archivo.txt
Automatic merge failed; fix conflicts and then commit the result.</pre>

            <p>Git marca los conflictos en el archivo así:</p>
            <pre>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
console.log("Versión de la rama actual");
=======
console.log("Versión de la rama que estás fusionando");
&gt;&gt;&gt;&gt;&gt;&gt;&gt; rama-b</pre>

            <p><strong>Cómo resolver conflictos:</strong></p>
            <ol>
                <li>Abre el archivo marcado con conflictos</li>
                <li>Busca las marcas <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>,
                    <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>
                </li>
                <li>Decide qué código mantener (o combina ambos manualmente)</li>
                <li>Elimina las marcas de conflicto</li>
                <li>Guarda el archivo</li>
                <li>Marca el conflicto como resuelto:
                    <pre>git add archivo.txt</pre>
                </li>
                <li>Completa la fusión con un commit:
                    <pre>git commit</pre>
                </li>
            </ol>

            <p><strong>Abortar una fusión conflictiva:</strong></p>
            <pre>git merge --abort</pre>
            <p>Esto deshace el intento de fusión y vuelve al estado anterior.</p>
        </section>

        <section>
            <h2>git rebase - Reescribir la Historia (Avanzado)</h2>
            <p><code>git rebase</code> es una alternativa a <code>git merge</code> que crea una historia más lineal y
                limpia.</p>

            <p><strong>Diferencia conceptual:</strong></p>
            <ul>
                <li><strong>Merge:</strong> Crea un commit de fusión que conecta dos ramas (preserva toda la historia)
                </li>
                <li><strong>Rebase:</strong> "Mueve" tus commits encima de otra rama, reescribiendo la historia como si
                    siempre hubieran estado ahí</li>
            </ul>

            <pre>git checkout mi-rama
git rebase main</pre>

            <figure>
                <figcaption>Antes del Rebase</figcaption>
                <pre>
main:     A ← B ← D
             ↓
          mi-rama: C ← E
        </pre>
            </figure>

            <figure>
                <figcaption>Después del Rebase</figcaption>
                <pre>
main:     A ← B ← D ← C' ← E'  (C y E reescritos encima de D)
        </pre>
            </figure>

            <p><strong>Regla de oro:</strong> <strong>Nunca hagas rebase de commits que ya compartiste con
                    otros</strong>
                (commits que ya hiciste push). Rebase reescribe historia, y si otros ya tienen esos commits, causarás
                caos
                en sus repositorios.</p>

            <p><strong>Cuándo usar rebase:</strong></p>
            <ul>
                <li>Para mantener una historia limpia y lineal</li>
                <li>Antes de fusionar tu rama a main (rebase primero, luego merge)</li>
                <li>Solo en ramas locales/privadas que no has compartido</li>
            </ul>

            <p><strong>Cuándo usar merge:</strong></p>
            <ul>
                <li>Cuando trabajas en equipos grandes</li>
                <li>Para preservar toda la historia exacta de cuándo ocurrieron las cosas</li>
                <li>Cuando ya compartiste los commits con otros</li>
            </ul>
        </section>

        <section>
            <h2>Estrategias de Branching Comunes</h2>

            <h3>Git Flow</h3>
            <p>Modelo popular para proyectos grandes:</p>
            <ul>
                <li><strong>main:</strong> Código en producción (siempre estable)</li>
                <li><strong>develop:</strong> Rama de integración para desarrollo</li>
                <li><strong>feature/:</strong> Ramas para nuevas funcionalidades (ej:
                    <code>feature/login-sistema</code>)
                </li>
                <li><strong>hotfix/:</strong> Ramas para correcciones urgentes en producción</li>
                <li><strong>release/:</strong> Ramas para preparar nuevas versiones</li>
            </ul>

            <h3>GitHub Flow (más simple)</h3>
            <ul>
                <li><strong>main:</strong> Siempre desplegable</li>
                <li><strong>feature-branches:</strong> Una rama por cada funcionalidad, se fusiona con Pull Request</li>
            </ul>

            <h3>Trunk-Based Development</h3>
            <ul>
                <li>Todos trabajan en <code>main</code> o en ramas de vida muy corta (1-2 días máximo)</li>
                <li>Integración continua constante</li>
            </ul>
        </section>

        <section>
            <h2>Comandos Útiles Adicionales</h2>

            <h3>Ver ramas remotas</h3>
            <pre>git branch -r        # Ver ramas remotas
git branch -a        # Ver todas las ramas (locales y remotas)</pre>

            <h3>Seguir ramas remotas</h3>
            <pre>git checkout --track origin/nombre-rama</pre>

            <h3>Ver qué ramas han sido fusionadas</h3>
            <pre>git branch --merged       # Ramas ya fusionadas (seguras para borrar)
git branch --no-merged    # Ramas aún no fusionadas</pre>

            <h3>Limpiar ramas obsoletas</h3>
            <pre>git branch -d $(git branch --merged | grep -v '\*\|main\|develop')</pre>
            <p>Borra todas las ramas locales ya fusionadas excepto main y develop.</p>
        </section>
    </main>

    <footer>
        <hr>
        <p><a href="git-comandos.html">← Anterior: Comandos Esenciales</a> | <a href="git-flujo.html">Siguiente: Flujo
                Completo Local-Remoto →</a></p>
        <p><a href="../index.html">← Volver al índice</a></p>
        <p><small>Creado por Rober Sonda — Guía de Control de Versiones 2025</small></p>
    </footer>
</body>

</html>